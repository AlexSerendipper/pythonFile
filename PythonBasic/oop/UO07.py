""" 关键字
参考D:\\IdeaWorkspace\\JavaBasic\\oop\\src\\useoop\\UO06.java

【self】完全等同于java的this,详见java
 它在方法内部使用，即这个方法所属对象的引用；
 它在构造器内部使用，表示该构造器正在初始化的对象。
 self 可以调用类的属性、方法和构造器
 当在方法内需要用到调用该方法的对象时，就用self。
  ✔ java中，使用this来区分属性和局部变量。比如：this.name（类中的属性） = name（构造器中的局部变量）。。。而属性和局部变量没有重名，我们会省略this
  ✔ 而python中，由于方法自带self，所以调用属性时 必须使用self.name（类中的属性）的方式

【super】完全等同于java的super，详见java
 super和this的用法相像，this代表本类对象的引用，super代表父类的内存间的标识
 super可用于调用父类的属性和方法
  ✔ 常用来区分子类中与父类重名的属性或重写的方法
  ✔ 未出现重名时可以省略

【super(形参列表)】可用于在子类构造器中调用父类的构造器
 共同点1：当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的
  构造器。同时，只能”二选一” ，且必须放在构造器的首行。。。否则编译报错
  即子类构造器一定间接或直接调用了父类的构造器（所以通常会在父类中声明一个空参构造器防止报错）
 java中
子类中所有的构造器默认都会访问父类中空参数的构造器。即构造器首行没有声明调用this/super构造器，默认调用super()。
 python中
✔ ✔ ✔ 如果子类没有提供任何构造器（init），它会默认调用其父类的无参数构造器。但如果子类提供了自己的构造器，默认情况下不会调用父类的构造器
✔ ✔ ✔ 由于python中只允许有一个构造器，并且python类是可以被多继承的，因此有如下用法可以更明确地控制调用的是哪个父类的构造方法。‌
 super().__init__()                        # 调用父类的空参构造器
 super(指定父类1, self).__init__()         # 调用指定父类的构造器

"""
