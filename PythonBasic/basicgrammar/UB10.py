""" list、tuple、set、dict等容器共性2:生成器和迭代器
【生成器概述】
列表推导式，我们可以直接创建一个列表。但是每次列表推导式的创建都会在直接在底层申请完所有的内存空间
所以，如果列表元素可以按照某种算法推算出来，就可以在循环的过程中不断推算出后续的元素呢。从而节省大量的空间。
在Python中，这种一边循环一边计算的机制，称为生成器:generator

【生成器获取】
1. 用列表推导式得到生成器，即把列表推导式的外层换成小括号
 g1 = (表达式 for x in range())
   g1.__next__()                         # 调用一次打印一个元素，依次产生
   next(g1)                                相同功能，next为内置函数，如果超出了产生的范围，则抛出异常StopIteration
   g1.send(None)                         # 调用一次打印一个元素，并往生成器中传值。使用前必须先send一个None值。因为yield相当于直接return，然后暂停
    g1.send('value')                      # 第二次调用时，将value赋值给yield所赋值的元素

2. 利用函数得到生成器
# 只要函数中出现yield关键字，函数就变成生成器了
# 调用函数，接收调用的结果就是生成器。继而使用next函数即可
def func()
   n = 0
   while True:
        n += 1
        yield n                            # 生成器标志，实际上调用时运行到这里就会暂停并return，下一次调用从这里开始
   return xxx                              # 当生成器结束了，返回的提示可以写在这
                                             即如果超出限制还在调用，返回该提示信息

【可迭代对象】
 生成器、元组、列表、集合、字典、字符串
 isinstance(list1.Iterable)             # 判断对象是否是可迭代的

【迭代器】与java中集合的迭代器几乎一样
 迭代器从可迭代对象的第一个元素开始访问，直到所有的的元素访问结束，迭代器只能往前不会后退
 生成器本身即是迭代器，其他对象需要转为迭代器
 iter1 = iter(可迭代对象)               # 得到迭代器
 next(iter1)                           # 调用可迭代对象，调用一次打印一个元素


【生成器与迭代器的区别】
1）生成器在每次产生一个值后会自动保存当前的状态，下次调用时会从上次离开的地方继续执行。
   而迭代器则不会自动保存状态，它依赖于用户显式地请求下一个值。
2）生成器在迭代过程中只会生成当前需要的值，而不是一次性生成所有的值，所以它可以处理大数据集，而不会耗尽内存。
  迭代器则可能需要一次性生成所有的值。
3）迭代器可以被多次迭代，每次迭代都会从头开始。
   而生成器只能被迭代一次，因为它不保存整个序列，只保存当前的状态。
4）生成器更加灵活，可以使用任何种类的控制流语句（如if、while等）。而迭代器则需要在__next__()方法中实现所有的控制流逻辑。
总结来说，生成器是一种特殊的迭代器，

"""

# 利用生成器产生斐波那契数列
def func(len):
    a = 0
    b = 1
    for i in range(len):  # 产生len个数
        yield b
        a, b = b, a + b  # b的值给a作为上一个数，a+b的值赋值给b，作为当前的数
    return '结束了'


g1 = func(8)
n = 0
while n < 8:
    print(next(g1))
    n = n + 1


# g1.send的使用示例, 可以断点查看
def gen():
    i = 0
    while i < 10:
        temp = yield i
        print('temp：', temp)
        i += 1
    return '结束了'


g2 = gen()
g2.send(None)
g2.send('敏敏')
g2.send('健健')


